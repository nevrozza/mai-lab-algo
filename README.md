# Python. Лабораторная работа 3
### Cтруктуры данных и сортировки + Generators + Benchmark + CLI
- **Библиотеки:**
  - `cli` из [лаб. 2](https://github.com/nevrozza/mai-lab-bash) - _Пользовательский ввод_
  - `time` – _Замер времени_
  - `importlib`, `pkgutil`, `abc`
    
- **Интересные штучки:**
  - Реализована [очередь на стеках (i/o)](./src/structures/queue_on_stacks.py)
  - Добавлен [`counting_sort_dict`](./src/sorts/counting.py) _(флаг `-d` команды `counting`)_: позволяет избегать `MemoryError`, когда диапазон слишком большой.
  - Тест для [`bucket_sort`](./tests/test_sorts.py): использование `zip` и вычисление разницы между исходным числом и отсортированным из-за неточности float.
  - Для `bucket_sort` есть обёртка, которая нормализирует входные параметры: это можно отменить флагом -r
  - Команды `bucket` и `radix` имеют флаг "b": с ним первый параметр используется для _buckets или base_
  - Бенчмарки в конце лабы

### Что нового я познал?
- Разобрался в сортировках
- Научился замерять время выполнения функций, писать бенчмарки
- Узнал, что `MemoryError` не имеет `msg`


## Структура проекта
```
algos
├── src
│   ├── benchmarking
│   │   ├── benchmark.py		# Функции: `timeit_once` и `benchmark_sorts`
│   │   ├── generators.py		# Генераторы рандомных списков с числами
│   │   └── run_benchmark.py	# Запуск бенчмарков, описание сценариев
│   ├── cli						# CLI из лр2 (вырезана работа с файлами)
│   ├── formulas				# Факториал и Фибоначчи
│   ├── sorts					# Директория с реализациями сортировок (+ команды)
│   ├── structures
│   │   └── queue_on_stacks.py	# Очередь на стеках
│   ├── utils
│   │   ├── commands_abc.py		# Дефолтные команды для этого проекта
│   │   ├── consts.py			# Константы (строки с ошибками)
│   │   └── ...
│   └── main.py					# Входная точка в программу
└── tests						# Тесты сортировок, факториала и Фибоначчи, структуры
```

## Очередь на двух _stacks_
### Важный пойнт
Queue – FIFO, Stack – LIFO
### Идея
- Используем два стека: input и output
- Добавляем элементы в input
- Перед выводом `переливаем` все элементы из input в output и выводим
- Таким образом, первый (самый старый) элемент в input становится последним (самым новым) в output.
> FIFO - вывод самого старого, LIFO - вывод самого нового
- Получается, что выводится самый старый элемент, что соответствует FIFO

### Kartinka
<img width="1880" height="1327" alt="image" src="https://github.com/user-attachments/assets/cbd37c47-78a6-451c-95aa-a18c6ccfb054" />

## Бенчмарки
```
N = 100000
Алгоритм                    random_10k     nearly_sorted   many_duplicates    reverse_sorted
--------------------------------------------------------------------------------------------
Sorted()                      0.028558          0.005061          0.009775          0.001098
Radix Sort                    0.337263          0.270368          0.064756          0.275166
Counting Sort                 0.007035          0.016887          0.005160          0.015514
Counting Sort (Dict)          0.010263          0.018508          0.004866          0.014864
Quick Sort                    0.100376          0.084330          0.015371          0.083381
Heap Sort                     0.256286          0.243549          0.208943          0.225925
--------------------------------------------------------------------------------------------

N = 1000
Алгоритм                     random_1k         nearly_1k           dups_1k        reverse_1k
--------------------------------------------------------------------------------------------
Bubble Sort                   0.026541          0.013813          0.026149          0.032685
--------------------------------------------------------------------------------------------

N = 1000
Алгоритм              random_10k float
--------------------------------------
Bucket Sort                   0.005210
--------------------------------------

N = 10000
Алгоритм              random_10k float
--------------------------------------
Bucket Sort                   0.005210
--------------------------------------

n = 100
----------------------------------------
factorial (iter)       0.000087 сек
factorial (rec)        0.000180 сек
----------------------------------------

n = 35
----------------------------------------
fibo (iter)            0.000003 сек
fibo (rec)             2.476334 сек
----------------------------------------
```

## Quick start
> [!CAUTION]
> - Работа программы была проверена только на MacOS.
> - Для работы автодополнения необходимо запускать программу через консоль

 0) Установить `uv` _0_o_
 1) Клонировать этот репозиторий через git и активировать uv:
   ```
   git clone https://github.com/nevrozza/mai-lab-algo
   cd mai-lab-algo
   uv sync
   ```
 2) Запустить программу через `uv`:
    `uv run -m src.main`
 3) Вы великолепны!
