# Python. Лабораторная работа 2  
### Bash (Easy+Medium)

- **Библиотеки:**
    - `pathlib` — _Работа с путями_
    - `shutil` — _Файловые операции_
    - `shlex` – _Парсинг команд_
    - `readline` – _Автокомплит_
    - `logging` — _Запись всех действий в shell.log_
    - `json` — _Сохранение истории команд между сессиями_
    - `colorama` – _Цветной ввод_
    - `dataclass`, `enum`, `abc`
      
- **Интересные штучки:**
    - Поддержка [автокомплита](./src/terminal/autocomplete.py) _(чуть коряво)_
    - Поддержка ввода нескольких команд через ';'
    - `.trash` папка создаётся в `cwd`
    - Очень легко добавляются кастомные команды (см. [лаб. 3]()):
      - Необходимо просто создать и реализовать класс от [`BashCommand`](./src/terminal/command.py) (или [`UndoableBashCommand`](./src/commands/custom_abc/undoable_command.py))
        
      > `UndoableBashCommand`, [`ArchiveBashCommand`](./src/commands/custom_abc/archive_command.py): ABC наследники от `BashCommand` – можно реализовывать свои abc по этому принципу

    - Есть возможность добавить полную поддержку _windows_:
      - Над pathlib реализована абстракция [`FS`](./src/terminal/file_system/fs.py).
      - Все команды обращаются к ней.
      - Возможна подмена инстанса `fs` на кастомный класс, наследованный от `FS`.
    - Вывод из команды `tuple[list[BashError], str]]`:
      - `list[BashError]` – список ошибок, которые не прерывают исполнение команды (случаи с `ls dir1 dir2`), но сообщение о них логгируются и выводятся
      - `str` – строка, которую необходимо напечатать (вывод команды)
      - [`PrintBuilder`](./src/utils/print_builder.py) – кастомный класс, который облегчает создание одного `str` для принта нескольких строк. (`PrintBuilder.get() -> str`)
      - Если есть ошибка, которая прерывает исполнение команды, то вызывается обычный `raise`

### Что нового я познал?
- Каково быть **не** козерогом
- Научился работать с `pathlib`, `shutil`, `shlex` и `logging`
- Написал кастомный [декоратор](./src/terminal/file_system/resolve_path.py), который работает с методами и функциями (проверяет сигнатуру через `inspect`)

## Структура проекта
```
bash
├── src
│   ├── terminal
│   │   ├── file_system
│   │   │   ├── fs.py						# Обёртка над FS для операций с файловой системой
│   │   │   ├── fs_properties.py			# Проверка свойств Path
│   │   │   └── ...
│   │   ├── autocomplete.py					# Автодополнение ввода в терминале
│   │   ├── command.py						# Родительский класс для всех команд терминала
│   │   ├── terminal.py						# Основной цикл ввода, разбор и выполнение команд, инициализация среды
│   │   └── history.py						# Singleton: управление историей
│   ├── commands
│   │   ├── import_default_commands.py		# Импорт всех *_command.py из подпапок
│   │   ├── custom_abc						# archive, unarchive, undoable
│   │   ├── archive							# zip, unzip, tar, untar
│   │   ├── files_content					# cat, grep
│   │   ├── history							# history, undo
│   │   ├── navigation						# cd, ls
│   │   └── undoables						# cp, mv, rm
│   ├── core
│   │   ├── config.py						# Настройки проекта: имена файлов, флаги поведения
│   │   ├── errors.py						# Кастомные ошибки
│   │   └── logging.py						# Инициализация логгера, функция log()
│   ├── utils
│   │   ├── print_builder.py				# Многострочный вывод в строку
│   │   ├── could_be_undo.py				# Проверка, можно ли отменить запись из истории
│   │   └── ...
│   └── main.py								# Входная точка в программу
└── tests									# Тесты для команд
```
## Kartinka
<img width="2162" height="1307" alt="image" src="https://github.com/user-attachments/assets/1bb0e2dc-f010-48ba-8092-d3e94c7ffbb9" />

Представленная архитектура позволяет использовать `bash` как библиотеку в других программах

## Алгоритм
1) `main.py`: Инициализация `Terminal` и `Logger`
    - `terminal.py`: Инициализация `Autocomplete`, `HistoryManager`, импорт дефолтных команд
2) `main.py`: Запуск `cycle_input()`
3) `terminal.py`: Считывание ввода и парсинг команд:
   - Сплит строки по ';'
   - Парсинг полученных строк через `shlex` (первый элемент - название команды)
   - Попытка добавить команду из `BashCommand.get_command`, если не вышло: `log(command not found)`
   - В команду передаются `raw_params` - все элементы из `shlex`, кроме первого
4) `command.py`: Начало выполнение команд
   - Парсинг параметров: `raw_params` разбирают на `params` и `flags`
   > Во время этого происходит первичная проверка параметров: нельзя передать аргументов больше, чем указано в команде; проверяется поддерживаемость флагов
   - Валидация параметров (`params`): _чаще всего проверка на `path.exists()`, etc._
   > Могут быть выкинуты критические (`raise`) и не очень ошибки (`list[BashError]`)
   >
   > _Не критические ошибки выводятся после выполнения команды перед выводом output'а_
   - Выполнение команды
5) `terminal.py`: Вывод ошибок/ответа команды
   - Команда может прерваться, если был вызван `raise`: ловим и логгируем ошибку
   - Команда возвращает список ошибок и ответ: принт ошибок, после чего выводим ответ
     ```
     meow@user:~/Desktop$ ls dir1 backend
     ls: cannot access 'dir1': No such file or directory
     chroma/   data/ 
     ```
   - Если всё было выполнено без ошибок, команда добавляется в историю с тегом `SUCCESS`, только тогда её можно отменить. Иначе `ERROR`
6) Выход из цикла `cycle_input()` через `Ctrl+C`

> [!NOTE]
> Для **тестирования** (28 тестов выполнения команд) была использована `tmp_path fixture`.
> Это позволяет тестировать в отдельной временной среде.
> 
> **Логи и история не сбрасываются!**

## Quick start
> [!CAUTION]
> - Работа программы была проверена только на MacOS.
> - Для работы автодополнения необходимо запускать программу через консоль

 0) Установить `uv` _0_o_
 1) Клонировать этот репозиторий через git и активировать uv:
   ```
   git clone https://github.com/nevrozza/mai-lab-bash
   cd mai-lab-bash
   uv sync
   ```
 4) Запустить программу через `uv`:
    `uv run -m src.main`
 5) Вы великолепны!

 _а где 2 и 3..._
